##接口

>接口主要用来描述类具有什么功能，而不给出每个功能的具体实现。一个类可以实现一个或多个接口，并在需要接口的地方，随时使用实现了相应接口的对象。

### 一、基本概念

如果类遵从某个特定接口，那么就履行这项服务。例如：Arrays类中的sort方法承诺可以对对象数组进行排序，但要求满足下列前提：对象所属的类必须实现了Comparable接口。Comparable接口的代码如下：

```java
public interface Comparable
{
  int compareTo(Object other);
}
```

**接口中的所有方法自动地属于public**。因此，在接口声明方法时，不必提供关键字public。接口可以包含一个或多个方法，在接口中还可以定义常量，但是**接口决不能含有实例域**。

提供实例域和方法实现的任务应该由实现接口的那个类来完成。因此可以将接口看成是没用实例域的抽象类。

### 二、接口的特性

接口不是类，尤其不能使用new运算符实例化一个接口。

```java
x = newComparable(。。。)//error错误！！！
```

但是可以声明接口的变量。

```java
Comparable x；
```

接口变量必须引用实现了接口的类对象。

```java
x = new Employee();//提供了实现Comparable接口的对象Employee。
```

与可以建立类的继承关系一样，接口也可以被扩展。这里允许存在多条具有较高通用性的接口道较高专用性的接口的链。例如：

```java
public interface Moveable{
  void move(double x ,double y);
}

//以Moveable的接口扩展
public interface Powered extends Moveable{
  
  double milesPerGallon();
  double SPEED_LIMIT = 95;//接口中可以包含常量。  
}
```

在接口中不能包含实例域或静态方法，但却可以包含常量。与接口中方法都自动的被设置为public一样，接口中的域将自动被设为public static final。

**尽管每个类只能够拥有一个超类，但却可以实现多个接口**。解决一个子类不能拥有多个爸爸的痛点，故提出了接口(个人自以为是的想法)。

**接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性**。

### 三、静态方法和默认方法

在JavaSE8中，允许在接口中增加静态方法。在实现自己的接口时，不再需要为实用工具方法提供另外一个伴随类。

可以为接口提供一个默认实现。必须用default修饰符标记这样一个方法。

```Java
public interface Comparable<T> {
  default int compareTo(T other){return 0;}
}
```

如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，会发生什么情况？Java解决这种二义性的规则如下：

1）**超类优先**。如果超类提供了一个具体方法，同名而且有相同类型参数的默认方法会被忽略。

2）接口冲突。如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型(不论是否是某人参数)相同的方法，必须覆盖这份方法来解决冲突。